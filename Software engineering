#include <cstdio>
#include <queue>
#include <ctime>

constexpr int MAX_N{ 10 };
int maze[MAX_N][MAX_N];
bool inq[MAX_N][MAX_N]{ false };
int dir_x[4]{ 0, 0, 1, -1 };
int dir_y[4]{ 1, -1, 0, 0 };

struct point {
    int x;
    int y;
    int steps;
    point() : x{ 0 }, y{ 0 }, steps{ 0 } {}
    point(int _x, int _y) : x{ _x }, y{ _y }, steps{ 0 } {}
};

bool isValid(int& x, int& y, int& size) {
    if (x >= size - 1 || x < 1 || y >= size - 1 || y < 1)  return false;
    if (maze[x][y] == 1)  return false;
    return !inq[x][y];
}

int bfs(point& start, int& size) {
    std::queue<point> q;
    q.push(start);

    point now, temp;
    while (!q.empty())
    {
        now = q.front();
        q.pop();
        if (now.x == size - 2 && now.y == size - 2)  return now.steps;
        for (int i = 0; i < 4; i++)
        {
            int newX = now.x + dir_x[i];
            int newY = now.y + dir_y[i];
            if (isValid(newX, newY, size))
            {
                temp.x = newX;
                temp.y = newY;
                temp.steps = now.steps + 1;
                q.push(temp);
                inq[newX][newY] = true;
            }
        }
    }

    return -1;
}

int main() {

    int size{ 0 };
    scanf_s("%d", &size);

    for (int i = 0; i < size; i++)
    {
        for (int j = 0; j < size; j++)
        {
            scanf_s("%d", &maze[i][j]);
        }
    }

    point start{ 1, 1 };
    
    auto st = clock();
    int res{ 0 };
    for (int i = 0; i < 10000; i++)
        res = bfs(start, size);
    auto et = clock();

    printf("Run bfs with %lf ms!\n", static_cast<double>(et - st));

    if (res == -1)
        printf("No solution");
    else
        printf("%d\n", res);

    return 0;
}
